#三份代码介绍,可以将对应视频文件置于每个任务文件下的build/Resources

#1、ArmorDetection.cpp（单一装甲板识别）

（一）思路：

      （1）将图像转化为HSV图像，便于根据灯柱颜色筛选出灯柱。
      
      （2）将HSV图像通过inrange()函数筛选出灯柱
      
      （4）canny轮廓检测，并且将轮廓进行膨胀使其相连，再获取轮廓，计算轮廓面积，通过面积大小筛去噪点
      
      （5）此时保留的轮廓方为有效轮廓，用boudrect()函数获取包围灯柱最小竖直矩形，进而提供装甲板上两个灯柱的最小竖直矩形的坐标获取装甲板中心坐标、以及在原图画交叉线
      
（二）代码测试steps：

	i)首先执行代码colorDetection6.cpp，对对象图像进行处理，该程序可以提供图形化滑动条调整各项参数，并实时呈现处理效果，从而获得颜色识别的六个参数， 
	hmin, smin, vmin；hmax, smax, vmax;
	
	    #inRange(imgHSV, lower, upper, mask);
	    
	    该函数可以从hue、saturation、value三个维度进行颜色的筛选，将HSV图像二值化，根据参数筛选出的颜色部分为白色，而其他部分为黑色。从而
	    
	ii）将参数填入该函数对应参数对应定义部分
	
	iii）修改读取图像或视频的地址即可执行代码 
	
（三）执行代码steps：

        i）在task1目录下，$cd build
			  $./ArmorDetection
			  
#2、ArmorDetection.cpp（转动装甲板识别）

##思路：
      （1）将图像转化为HSV图像，便于根据灯柱颜色筛选出灯柱。

      （2）将HSV图像通过inrange()函数筛选出灯柱
      
      （4）canny轮廓检测，并且将轮廓进行膨胀使其相连，再获取轮廓，计算轮廓面积，通过面积大小筛去噪点
      
      （5）由于图像可能同时存在n（>=2）个灯柱，因此需要用两个灯柱所构成的矩形长宽比来确定这两个灯柱是否为同一装甲板上的灯柱。
      
      （5）此时保留的轮廓方为有效轮廓，用boudrect()函数获取包围灯柱最小竖直矩形，进而提供装甲板上两个灯柱的最小竖直矩形的坐标获取装甲板中心坐标、以及在原图画交叉线

##代码测试steps：与1号代码基本一致

   执行代码steps：
        i）在task1目录下，$cd build
			  $./armorDetection2
			  
#3、fanDetection.cpp（单一装甲板识别）
##（一）思路：

      （1）将图像转化为HSV图像，便于根据灯柱颜色筛选出灯柱。

      （2）将HSV图像通过inrange()函数筛选出灯柱
      
      （4）canny轮廓检测，并且将轮廓进行膨胀使其相连（特别是使未击打部分扇叶连接成“锤子”形状），再获取轮廓，计算轮廓面积，通过面积大小筛去噪点
      
      （5）此时保留的轮廓方为有效轮廓，用minArearect()函数获取包围扇叶最小矩形，并将该矩形内所截取图像进行透视变换，通过模板匹配的方式判断该扇叶使否已经被击打。
      
      （5）识别出未击打扇叶（锤子形状）后，通过找到子轮廓从而找到装甲板对应位置，用minArearect()函数获取包围装甲板最小矩形，从而找出中心点坐标。
      
##（二）执行代码steps：

        i）在task1目录下，$cd build
			  $./fanDetection

#tips：所用识别图像或视频均存储在build下的Resources中



